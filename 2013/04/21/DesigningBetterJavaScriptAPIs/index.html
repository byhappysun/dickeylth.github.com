<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[译]设计更好的JavaScript API | 前端探幽</title>
  <meta name="author" content="Dickey Leo">
  
  <meta name="description" content="本文讨论了在你编写你自己的应用和库之前和期间需要考虑的一些重要的事情。我们将关注于如何让开发者们更易于理解你的代码。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[译]设计更好的JavaScript API"/>
  <meta property="og:site_name" content="前端探幽"/>

  
    <meta property="og:image" content="/img/jsapis/cover.jpg" />
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="前端探幽" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<meta name="google-translate-customization" content="a9a07b64678ddc7b-87bb7e79e577965f-gd475b0b319f70a25-13"></meta>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-44813171-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">前端探幽</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">所有文章</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-04-20T16:00:00.000Z"><a href="/2013/04/21/DesigningBetterJavaScriptAPIs/">4月 21, 2013</a></time>
      
      
  
    <h1 class="title">[译]设计更好的JavaScript API</h1>
  

    </header>
    <div class="entry">
      
        <p>本文讨论了在你编写你自己的应用和库之前和期间需要考虑的一些重要的事情。我们将关注于如何让开发者们更易于理解你的代码。<br><a id="more"></a><br>By Rodney Rehm</p>
<p>原文链接：<a href="http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/" target="_blank">http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/</a></p>
<p><strong>你常常会发现，自己写的 JavaScript 代码比一个 jQuery 插件还要长。你的代码需要做一大堆的工作，（理想情况下）它会被许多人以不同方式来调用。他们的需求、学识和期望不尽相同。</strong></p>
<p><img src="/img/jsapis/Pie-chart.jpg" alt=" 花在构建 / 使用库上的时间对比 " title="Time Spend on Creating/Using The Library"></p>
<p>本文讨论了在你编写你自己的应用和库之前和期间需要考虑的最重要的那些事。我们将关注于如何让其他开发者<em>易于理解</em>你的代码。虽然在示例中会有很多话题涉及 jQuery，但本文并不探讨 jQuery 或是如何为 jQuery 编写插件。</p>
<p>Perter Drucker 曾经说过：“计算机是个白痴”。不要为白痴写代码，而是为人写！让我们来探讨下如何设计开发者们会乐于使用的 API。</p>
<h2 id=" 目录 ">目录</h2>
<ul>
<li>连贯接口</li>
<li>一致性</li>
<li>处理参数</li>
<li>可扩展性</li>
<li>钩子机制</li>
<li>生成访问器</li>
<li>引用之怖</li>
<li>连续性问题</li>
<li>处理错误</li>
<li>向异步出发</li>
<li>调试连贯接口</li>
<li>文档化 API</li>
<li>结语</li>
</ul>
<h2 id=" 连贯接口 ">连贯接口</h2>
<p><a href="http://en.wikipedia.org/wiki/Fluent*interface#JavaScript" target="_blank">连贯接口</a>通常被称为<em>链式调用</em>（尽管不全对）。对于初学者而言它看上去像<em>jQuery 风格</em>。虽然我相信这种 API 风格是 jQuery 大获成功的一个重要因素，但它并不是由 jQuery 开发者们创造的。这项荣誉似乎应该归于 Martin Fowler。早在 2005 年，大约 jQuery 发布的前一年，他就<a href="http://martinfowler.com/bliki/FluentInterface.html" target="_blank">发明了这个术语</a>。然而 Fowler 仅仅对它进行了命名，事实上连贯接口已经存在很久了。</p>
<p>除了最重要的简单化，jQuery 还处理了浏览器兼容性问题。这种连贯接口设计一直是这个极为成功的库中我的最爱。我如此喜欢这种特别的 API 风格，以至于我想要立刻将这种风格也应用到<a href="http://medialize.github.io/URI.js/" target="_blank">URI.js</a>中。在调整 URI.js 的 API 期间，我经常翻查 jQuery 源码，发现那些可以尽可能简化实现的小技巧。我发现并非只有我在做这种尝试。<a href="https://twitter.com/leaverou" target="_blank">Lea Verou</a>创建了<a href="http://lea.verou.me/chainvas/" target="_blank">chainvas</a>——一个用来将规则的 getter/setter API 包装为亲切的连贯接口的工具。UnderScore 的<code>_.chain()</code>也实现了相似的功能。事实上，新一代的库大多都支持链式调用。</p>
<h3 id=" 链式调用 ">链式调用</h3>
<p>链式调用的主要思想就是使代码尽可能流畅易读，从而可以更快地被理解。有了<em>链式调用</em>，我们可以将代码组织为类似语句的片段，增强可读性的同时减少干扰。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">// regular API calls to change some colors and add an event-listener</span>
<span class="keyword">var</span> elem = document.getElementById(<span class="string">"foobar"</span>);
elem.style.background = <span class="string">"red"</span>;
elem.style.color = <span class="string">"green"</span>;
elem.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> {</span>
  alert(<span class="string">"hello world!"</span>);
}, <span class="literal">true</span>);

<span class="comment">// (imaginary) method chaining API</span>
DOMHelper.getElementById(<span class="string">'foobar'</span>)
  .setStyle(<span class="string">"background"</span>, <span class="string">"red"</span>)
  .setStyle(<span class="string">"color"</span>, <span class="string">"green"</span>)
  .addEvent(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> {</span>
    alert(<span class="string">"hello world"</span>);
});
</pre></td></tr></table></figure>



<p>注意我们如何避免将元素的引用赋给一个变量而后一再地调用。</p>
<h3 id=" 命令查询分离 ">命令查询分离</h3>
<p><a href="http://en.wikipedia.org/wiki/Command-query*separation" target="_blank">命令查询分离</a>（Command and Query Separation，CQS）是源于命令式编程的一个概念。那些改变对象的状态（内部的值）的函数称为<em>命令</em>，而那些检索值的函数称为<em>查询</em>。原则上，查询函数返回数据，命令函数返回状态，各司其职。这个概念是今天我们在大部分库中看到的普遍的 getter 和 setter 方法的依据之一。由于<em>连贯接口</em>返回一个自引用以实现链式方法调用，事实上已经打破了为<em>命令</em>设定的规则，因为它们本来不应有返回值。除了这一点（很容易被忽略）以外，我们还（有意）打破这个概念从而使 API 尽可能保持简单。jQuery 中的<code>css()</code>方法就是这种实践的一个很好的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> $elem = jQuery(<span class="string">"#foobar"</span>);

<span class="comment">// CQS - command</span>
$elem.setCss(<span class="string">"background"</span>, <span class="string">"green"</span>);
<span class="comment">// CQS - query</span>
$elem.getCss(<span class="string">"color"</span>) === <span class="string">"red"</span>;

<span class="comment">// non-CQS - command</span>
$elem.css(<span class="string">"background"</span>, <span class="string">"green"</span>);
<span class="comment">// non-CQS - query</span>
$elem.css(<span class="string">"color"</span>) === <span class="string">"red"</span>;
</pre></td></tr></table></figure>



<p>如你所见，getter 和 setter 方法都被合并到一个单一的方法中。要执行（即<em>查询</em>或是<em>命令</em>）的功能是由被传入到这个函数的参数个数所决定，而不是哪个函数被调用。这使得我们可以暴露更少的方法，从而以更少的代码实现同样的目标。</p>
<p>将 getter 和 setter 方法压缩到单一方法中以创建一个连贯接口并不是必要的，这取决于个人喜好。你的文档应该对你决定采用的方法提供清晰的描述。后文中我会讲到 API 文档化，但在这里我想指出，多函数签名的文档化可能会比较麻烦。</p>
<h3 id=" 向流畅前进 ">向流畅前进</h3>
<p>虽然方法链已经为实现流畅的代码完成了大量的工作，但还没完。为了阐明实现<em>流畅</em>的下一步，我们假定要写一个处理日期间隔的简短的库。一个日期间隔开始于某个日期，结束于另一个日期。一个日期并不必要与一个日期间隔相关联。于是我们得出这个简单的构造器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// create new date interval</span>
<span class="keyword">var</span> interval = <span class="keyword">new</span> DateInterval(startDate, endDate);
<span class="comment">// get the calculated number of days the interval spans</span>
<span class="keyword">var</span> days = interval.days();
</pre></td></tr></table></figure>



<p>虽然初看上去是对的，下面这个例子可以看出问题所在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">31</span>)
<span class="keyword">var</span> interval = <span class="keyword">new</span> DateInterval(startDate, endDate);
<span class="keyword">var</span> days = interval.days(); <span class="comment">// 365</span>
</pre></td></tr></table></figure>



<p>我们写了一大堆可能并不需要的变量和其他东西。更好的解决方案是在 Date 对象上添加一个函数来返回一个时间间隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">// DateInterval creator for fluent invocation</span>
<span class="built_in">Date</span>.prototype.until = <span class="function"><span class="keyword">function</span><span class="params">(end)</span> {</span>

  <span class="comment">// if we weren't given a date, make one</span>
  <span class="keyword">if</span> (!(end <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    <span class="comment">// create date from given arguments,</span>
    <span class="comment">// proxy the constructor to allow for any parameters</span>
    <span class="comment">// the Date constructor would've taken natively</span>
    end = <span class="built_in">Date</span>.apply(<span class="literal">null</span>, 
      <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)
    );
  }

  <span class="keyword">return</span> <span class="keyword">new</span> DateInterval(<span class="keyword">this</span>, end);
};
</pre></td></tr></table></figure>



<p>现在我们可以以一种流畅、易写易读的方式创建<code>DateInterval</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="keyword">var</span> interval = startDate.until(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">31</span>);
<span class="keyword">var</span> days = interval.days(); <span class="comment">// 365</span>

<span class="comment">// condensed fluent interface call:</span>
<span class="keyword">var</span> days = (<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">1</span>))
  .until(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">31</span>) <span class="comment">// returns DateInterval instance</span>
  .days(); <span class="comment">// 365</span>
</pre></td></tr></table></figure>



<p>正如你在最后这个例子中所见，只需要声明更少的变量、书写更少的代码就可以完成同样的功能，并且执行语句读起来几乎就像一个英语句子。通过这个例子，你会意识到，方法链只是连贯接口的一部分，它们算不上是同义词。为了保证流畅性，你必须想明白代码流——从哪里来、要往哪里去。</p>
<p>上面这个例子是通过在原生对象上扩展自定义函数来说明流畅性。和是否使用分号一样，这就像一种宗教信仰。在<a href="http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/" target="_blank">《是否应该扩展内置原生对象？》</a>这篇文章中，<a href="https://twitter.com/kangax" target="_blank">kangax</a>说明了这种方法的优缺点。尽管这个问题见仁见智，但保持一致性是人人都认可的原则。顺便说一句，即使是那些“不应以自定义方法污染原生对象”的拥护者可能也会接受下面有些技巧性的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="built_in">String</span>.prototype.foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Foo(<span class="keyword">this</span>);
}

<span class="string">"I'm a native object"</span>.foo()
  .iAmACustomFunction();
</pre></td></tr></table></figure>



<p>通过这种方式，你的自定义函数仍然在你的命名空间下，但是可以通过其他对象访问到它。确保你的代码中的<code>.foo()</code>对应的方法名是非统称（non-generic）关键字，以避免与其他的 API 冲突，并确保你的代码中提供了恰当的<code>.valueOf()</code>和<code>.toString()</code>方法以转换回原始的基本类型。</p>
<h2 id=" 一致性 ">一致性</h2>
<p><a href="https://twitter.com/jaffathecake" target="_blank">Jake Archibald</a>曾经在一张幻灯片上定义了<em>一致性</em>。它可以简单称为<em><a href="http://www.slideshare.net/slideshow/embed_code/5426258?startSlide=59" target="_blank">拒绝 PHP</a></em>。永远不要在你的代码中出现类似<em>str_repeat()</em>、<em>str_pos()</em>、<em>substr()</em>这样的函数命名，也不要交换参数的位置。如果你在某处声明了<code>find_in*array(haystack, needle)</code>函数，再定义<code>findInString(needle, haystack)</code>函数将会使你的代码变得像噩梦一般。</p>
<h3 id=" 命名 ">命名</h3>
<blockquote>
<p>“There are only two hard problems in computer science: cache-invalidation and naming things.”</p>
<p>“在计算机科学领域只有 2 个难题：缓存失效和命名。”</p>
<p>— Phil Karlton</p>
</blockquote>
<p>我参加过不计其数的讲授如何更好地命名的讨论和会议，每次在离开前都会听到上面这句引述，但还是没有真正地学会如何命名。我的建议归纳为<em>保持简短但具有描述性并且跟随你的直觉</em>。但是最重要的是，保持一致性。</p>
<p>上面的<code>DateInterval</code>的例子引入了一个名为<code>until()</code>的方法。我们本可以将其命名为<code>interval()</code>，这样会与返回值更为接近，然而前者<em>可读性</em>更好。找出一行你喜欢的用词并且坚持下去。一致性占据 90% 的重要性。选择一种风格并且保持下去——即使在将来某个时候你开始反感这种风格了。</p>
<h2 id=" 处理参数 ">处理参数</h2>
<p><img src="/img/jsapis/good-intention.jpg" alt="Good Intentions"></p>
<p>你的方法如何接收数据比让它们具有可链性更为重要。虽然方法链是非常普遍的，你可以很容易地在你的代码中实现，但是处理参数却不同。你需要想想你提供的方法最有可能被如何使用。调用你的 API 的代码会不会重复调用某个函数？为什么会重复调用？如何使你的 API 帮助开发者减少这种重复调用函数的干扰？</p>
<p>jQuery 的<code>css()</code>方法可以在一个 DOM 元素上设置样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>jQuery(<span class="string">"#some-selector"</span>)
  .css(<span class="string">"background"</span>, <span class="string">"red"</span>)
  .css(<span class="string">"color"</span>, <span class="string">"white"</span>)
  .css(<span class="string">"font-weight"</span>, <span class="string">"bold"</span>)
  .css(<span class="string">"padding"</span>, <span class="number">10</span>);
</pre></td></tr></table></figure>



<p>这是一种模式！每个方法调用都为一种样式指定一个值。这就要求这种方法能接收一个映射作为参数传入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>jQuery(<span class="string">"#some-selector"</span>).css({
  <span class="string">"background"</span> : <span class="string">"red"</span>,
  <span class="string">"color"</span> : <span class="string">"white"</span>,
  <span class="string">"font-weight"</span> : <span class="string">"bold"</span>,
  <span class="string">"padding"</span> : <span class="number">10</span>
});
</pre></td></tr></table></figure>



<p>jQuery 的<code>on()</code>方法可以注册事件处理器。和<code>css()</code>一样它也可以接收一组映射格式的事件，但更进一步地，它允许单一处理器可以被多个事件注册：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">// binding events by passing a map</span>
jQuery(<span class="string">"#some-selector"</span>).on({
  <span class="string">"click"</span> : myClickHandler,
  <span class="string">"keyup"</span> : myKeyupHandler,
  <span class="string">"change"</span> : myChangeHandler
});

<span class="comment">// binding a handler to multiple events:</span>
jQuery(<span class="string">"#some-selector"</span>).on(<span class="string">"click keyup change"</span>, myEventHandler);
</pre></td></tr></table></figure>



<p>你可以采用下面的<em>方法模式</em>实现上面的函数签名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>DateInterval.prototype.values = <span class="function"><span class="keyword">function</span><span class="params">(name, value)</span> {</span>
  <span class="keyword">var</span> map;

  <span class="keyword">if</span> (jQuery.isPlainObject(name)) {
    <span class="comment">// setting a map</span>
    map = name;
  } <span class="keyword">else</span> <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) {
    <span class="comment">// setting a value (on possibly multiple names), convert to map</span>
    keys = name.split(<span class="string">" "</span>);
    map = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) {
      map[keys[i]] = value;
    }
  } <span class="keyword">else</span> <span class="keyword">if</span> (name === <span class="literal">undefined</span>) {
    <span class="comment">// getting all values</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.values;
  } <span class="keyword">else</span> {
    <span class="comment">// getting specific value</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.values[name];
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> map) {
    <span class="keyword">this</span>.values[name] = map[key];
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>



<p>如果你需要处理集合，考虑一下你可以为减少 API 使用者可能需要执行的循环次数做些什么。假设我们有一堆想要设置默认值的<code>&lt;input&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">data-default</span>=<span class="value">"foo"</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">data-default</span>=<span class="value">"bar"</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">value</span>=<span class="value">""</span> <span class="attribute">data-default</span>=<span class="value">"baz"</span>&gt;</span>
</pre></td></tr></table></figure>



<p>我们也许会以一个循环这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>jQuery(<span class="string">"input"</span>).each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> $<span class="keyword">this</span> = jQuery(<span class="keyword">this</span>);
  $<span class="keyword">this</span>.val($<span class="keyword">this</span>.data(<span class="string">"default"</span>));
});
</pre></td></tr></table></figure>



<p>如果我们可以绕过这种方式，采用一个简单的回调函数应用到集合中每个<code>&lt;input&gt;</code>元素上呢？jQuery 开发者已经想到这一点并且允许我们写更少的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery(<span class="string">"input"</span>).val(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> jQuery(<span class="keyword">this</span>).data(<span class="string">"default"</span>);
});
</pre></td></tr></table></figure>



<p>正是像这些接收映射参数、回调函数或序列化的属性名的细节，让你的 API 使用起来不仅更清晰，而且更舒服和高效。显然并非你的所有的 API 方法都会从这种方法模式中受益——何时这样做有意义，何时这样做是浪费时间，都完全取决于你。尽可能人性化地在这方面保持一致。<em>采用上面的技巧减少样版代码的需要，API 使用者会感激你的。</em></p>
<h3 id=" 处理类型 ">处理类型</h3>
<p>通常定义一个含参函数，你需要决定这个函数接受的参数类型。一个计算两个日期之间间隔的天数的函数会是像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>DateInterval.prototype.days = <span class="function"><span class="keyword">function</span><span class="params">(start, end)</span> {</span>
  <span class="keyword">return</span> <span class="built_in">Math</span>.floor((end - start) / <span class="number">86400000</span>);
};
</pre></td></tr></table></figure>



<p>可见，这个函数参数类型是数字——准确来说，一个微秒级的时间戳。尽管这个函数完成了我们所预期的效果，但它还不够通用。如果我们得处理<code>Date</code>对象或是代表日期的字符串这样的参数呢？难道使用者每次调用这个函数前都必须转换数据格式吗？不！只需要集中地对输入进行验证并且转换为我们需要的格式，而不是将参数处理凌乱地分散在调用 API 的代码中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>DateInterval.prototype.days = <span class="function"><span class="keyword">function</span><span class="params">(start, end)</span> {</span>
  <span class="keyword">if</span> (!(start <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    start = <span class="keyword">new</span> <span class="built_in">Date</span>(start);
  }
  <span class="keyword">if</span> (!(end <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    end = <span class="keyword">new</span> <span class="built_in">Date</span>(end);
  }

  <span class="keyword">return</span> <span class="built_in">Math</span>.floor((end.getTime() - start.getTime()) / <span class="number">86400000</span>);
};
</pre></td></tr></table></figure>



<p>在添加了这 6 行之后，我们使这个函数可以接受 Date 对象、数字型的时间戳、甚至像<code>Sat Sep 08 2012 15:34:35 GMT+0200 (CEST)</code>这样的日期字符串等类型的参数。我们并不知道他人会如何和为何使用我们的代码，但是多一点远见，就可以确保整合我们的代码会很轻松。</p>
<p>有经验的开发者会在上面的示例代码中注意到另一个问题。我们假定了<code>start</code>日期在<code>end</code>日期之前。如果 API 使用者偶然交换了这两个日期传入函数中，就会得到一个负的日期间隔。停下来好好考虑下这些场景吧。如果你得出的结论是负值不合理，那么就修复它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>DateInterval.prototype.days = <span class="function"><span class="keyword">function</span><span class="params">(start, end)</span> {</span>
  <span class="keyword">if</span> (!(start <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    start = <span class="keyword">new</span> <span class="built_in">Date</span>(start);
  }
  <span class="keyword">if</span> (!(end <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    end = <span class="keyword">new</span> <span class="built_in">Date</span>(end);
  }

  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(<span class="built_in">Math</span>.floor((end.getTime() - start.getTime()) / <span class="number">86400000</span>));
};
</pre></td></tr></table></figure>



<p>JavaScript 允许多种形式的类型转换。如果你需要处理基本类型（字符串、数字、布尔型），这种转换可以如此简单（而且很“简短”）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">castaway</span><span class="params">(some*string, some_integer, some*boolean)</span> {</span>
  some_string += <span class="string">""</span>;
  some*integer += <span class="number">0</span>; <span class="comment">// parseInt(some*integer, 10) is the safer bet</span>
  some*boolean = !!some*boolean;
}
</pre></td></tr></table></figure>



<p>我并不提倡随时随地都这么做。但是当整合你的代码时，这些看上去无害的代码也许会节省时间和减少麻烦。</p>
<h3 id=" 把 UNDEFINED 看作预期值 ">把<code>UNDEFINED</code>看作预期值</h3>
<p>有时候你的 API 事实上期望获得一个<code>undefined</code>值来设置一个属性值，可能是为了将一个属性值设为“未置值 (unset)”状态，也可能只是优雅地处理错误输入使你的 API 更加健壮。为了确定<code>undefined</code>是不是确实被传入到你的方法中，你可以检查<code>arguments</code>对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">testUndefined</span><span class="params">(expecting, someArgument)</span> {</span>
  <span class="keyword">if</span> (someArgument === <span class="literal">undefined</span>) {
    console.log(<span class="string">"someArgument was undefined"</span>);
  }
  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) {
    console.log(<span class="string">"but was actually passed in"</span>);
  }
}

testUndefined(<span class="string">"foo"</span>);
<span class="comment">// prints: someArgument was undefined</span>
testUndefined(<span class="string">"foo"</span>, <span class="literal">undefined</span>);
<span class="comment">// prints: someArgument was undefined, but was actually passed in</span>
</pre></td></tr></table></figure>



<h3 id=" 命名参数 ">命名参数</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>event.initMouseEvent(
  <span class="string">"click"</span>, <span class="literal">true</span>, <span class="literal">true</span>, window, 
  <span class="number">123</span>, <span class="number">101</span>, <span class="number">202</span>, <span class="number">101</span>, <span class="number">202</span>, 
  <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, 
  <span class="number">1</span>, <span class="literal">null</span>);
</pre></td></tr></table></figure>



<p><code>Event.initMouseEvent</code>的函数签名像是噩梦成真。开发者绝无可能不用查看文档就能想起来 <code>1</code>（倒数第二个参数）表示什么。不管你的文档写的有多么好，尽你所能让人们不必去查阅它！</p>
<h3 id=" 其他语言是如何做的 ">其他语言是如何做的</h3>
<p>眺望我们热爱的语言之外，我们发现 Python 中有个名为<a href="http://www.diveintopython.net/power*of_introspection/optional*arguments.html" target="_blank">命名参数</a>的概念。它允许你在声明一个函数时为参数提供默认值，允许你在调用上下文中声明属性名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">namesAreAwesome</span><span class="params">(foo=1, bar=2)</span> {</span>
  console.log(foo, bar);
}

namesAreAwesome();
<span class="comment">// prints: 1, 2</span>

namesAreAwesome(<span class="number">3</span>, <span class="number">4</span>);
<span class="comment">// prints: 3, 4</span>

namesAreAwesome(foo=<span class="number">5</span>, bar=<span class="number">6</span>);
<span class="comment">// prints: 5, 6</span>

namesAreAwesome(bar=<span class="number">6</span>);
<span class="comment">// prints: 1, 6</span>
</pre></td></tr></table></figure>



<p>有了这种设计，initMouseEvent() 就可以变得像一个自解释的函数调用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>event.initMouseEvent(
  type=<span class="string">"click"</span>, 
  canBubble=<span class="literal">true</span>, 
  cancelable=<span class="literal">true</span>, 
  view=window, 
  detail=<span class="number">123</span>,
  screenX=<span class="number">101</span>, 
  screenY=<span class="number">202</span>, 
  clientX=<span class="number">101</span>, 
  clientY=<span class="number">202</span>, 
  ctrlKey=<span class="literal">true</span>, 
  altKey=<span class="literal">false</span>, 
  shiftKey=<span class="literal">false</span>, 
  metaKey=<span class="literal">false</span>, 
  button=<span class="number">1</span>, 
  relatedTarget=<span class="literal">null</span>);
</pre></td></tr></table></figure>



<p>目前 JavaScript 中还不可能这样书写。虽然“JavaScript 的下一版本”（通常被称为 ES.next，ES6，或者 Harmony）会有<a href="http://wiki.ecmascript.org/doku.php?id=harmony:parameter*default_values" target="_blank">默认参数值</a>和<a href="http://wiki.ecmascript.org/doku.php?id=harmony:rest*parameters" target="_blank">可变参数</a>，但是命名参数仍然遥遥无期。</p>
<h3 id=" 参数映射 ">参数映射</h3>
<p>JavaScript 不是 Python（而且 ES.next 还很遥远），要克服“参数森林”的障碍，留给我们的可选方案非常少。jQuery（以及差不多它提供的每一个恰当的 API）采用了“option 对象 (option objects)”的概念。<code>jQuery.ajax()</code>方法签名提供了一个很好的例子。我们只需要传入一个对象，而不是一堆参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">nightmare</span><span class="params">(accepts, async, beforeSend, cache, complete, <span class="comment">/* and 28 more */</span>)</span> {</span>
  <span class="keyword">if</span> (accepts === <span class="string">"text"</span>) {
    <span class="comment">// prepare for receiving plain text</span>
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">dream</span><span class="params">(options)</span> {</span>
  options = options || {};
  <span class="keyword">if</span> (options.accepts === <span class="string">"text"</span>) {
    <span class="comment">// prepare for receiving plain text</span>
  }
}
</pre></td></tr></table></figure>



<p>这样不仅避免了疯狂而冗长的函数签名，也使得函数调用更具备描述性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>nightmare(<span class="string">"text"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="comment">/* and 28 more */</span>);

dream({
  accepts: <span class="string">"text"</span>,
  async: <span class="literal">true</span>,
  cache: <span class="literal">false</span>
});
</pre></td></tr></table></figure>



<p>此外，在更新的版本中如果我们会引入新的特性，也不必影响到函数签名（添加一个新的参数）。</p>
<h3 id=" 默认参数值 ">默认参数值</h3>
<p><a href="http://api.jquery.com/jQuery.extend/" target="_blank">jQuery.extend()</a>、<a href="http://underscorejs.org/#extend" target="_blank">_.extend()</a>和 Prototype 的<a href="http://api.prototypejs.org/language/Object/extend/" target="_blank">Object.extend</a>都可以帮你合并对象，允许你输入预置的 option 对象进行合并：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">var</span> default_options = {
  accepts: <span class="string">"text"</span>,
  async: <span class="literal">true</span>,
  beforeSend: <span class="literal">null</span>,
  cache: <span class="literal">false</span>,
  complete: <span class="literal">null</span>,
  <span class="comment">// …</span>
};

<span class="function"><span class="keyword">function</span> <span class="title">dream</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> o = jQuery.extend({}, default_options, options || {});
  console.log(o.accepts);
}

<span class="comment">// make defaults public</span>
dream.default*options = <span class="keyword">default</span>*options;

dream({ async: <span class="literal">false</span> });
<span class="comment">// prints: "text"</span>
</pre></td></tr></table></figure>



<p>默认值可以公开访问了，恭喜你拿到了附加分。这样一来，任何人都可以在集中地修改<code>accepts</code>的值为”json”，因而可以避免一再地指定这个选项。注意这个例子中总是会在初次读取选项对象时附加一个<code>|| {}</code>操作，从而可以保证无参传入时也能调用这个函数。</p>
<h3 id=" 好意 _——_ 也可能是“陷阱”">好意 —— 也可能是“陷阱”</h3>
<p>既然你已经知道了如何更加弹性地接收参数，让我们回到一条古谚：</p>
<blockquote>
<p>“With great power comes great responsibility!”</p>
<p>“能力越大，责任越大！”</p>
<p>— Voltaire</p>
</blockquote>
<p>类似大部分弱类型语言，JavaScript 在需要时会自动进行类型转换。一个简单的例子是测试真假与否：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="literal">true</span>;

<span class="keyword">if</span> (foo) {
  <span class="comment">// yep, this will execute</span>
}

<span class="keyword">if</span> (bar) {
  <span class="comment">// yep, this will execute</span>
}
</pre></td></tr></table></figure>



<p>我们相当习惯了这种自动转换。正是因为太习惯，以至于我们忘记了，即使有些值是真实存在的，从布尔值的角度它可能并不会被判为 true。有些 API 设计得如此的弹性以至于有些<em>过于聪明</em>了。看看<a href="http://api.jquery.com/toggle/" target="_blank">jQuery.toggle()</a>方法的签名吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>.toggle( <span class="comment">/* int */</span> [duration] [, <span class="comment">/* function */</span>  callback] )
.toggle( <span class="comment">/* int */</span> [duration] [, <span class="comment">/* string */</span>  easing] [, <span class="comment">/* function */</span> callback] )
.toggle( <span class="comment">/* bool */</span> showOrHide )
</pre></td></tr></table></figure>



<p>要解释明白为什么这些行为表现<em>完全</em>不同需要费点时间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="literal">true</span>;
<span class="keyword">var</span> $hello = jQuery(<span class="string">".hello"</span>);
<span class="keyword">var</span> $world = jQuery(<span class="string">".world"</span>);

$hello.toggle(foo);
$world.toggle(bar);
</pre></td></tr></table></figure>



<p>我们的<em>预期</em>是在两种情况下都使用<code>showOrHide</code>签名。然而事实上，<code>$hello</code>会以一秒的<code>duration</code>执行一次切换。这不是 jQuery 中的 bug，这只是一个<em>与期望不符</em>的案例。即使你是一个有经验的 jQuery 开发者，你也会不时被这种问题绊倒。</p>
<p>你尽可以如你所愿添加尽可能多的便利——但同时不要牺牲 API 的简洁性和健壮性（多半会）。如果你的代码中也提供了类似的 API，考虑一下提供一个单独的方法，例如<code>.toggleIf(bool)</code>来替代。不论采用什么办法，记得保持你的 API 的一致性！</p>
<h2 id=" 可扩展性 ">可扩展性</h2>
<p><img src="/img/jsapis/developing-possibilities.jpg" alt="Developing Possibilities"></p>
<p>在 option 对象部分，我们谈到了可扩展的配置。让我们来讨论下允许 API 使用者扩展核心和 API 本身。这一点很重要，因为它可以使你的代码关注重要的事情，同时可以使 API 使用者自己处理边界情况。好的 API 设计都很简约。提供丰富的配置项当然很好，但是过多的配置项会导致你的 API 变得臃肿晦涩。关注主要的应用场景，只提供你的 API 使用者需要的大部分功能，剩下的应该留给他们决定。为了允许 API 使用者们扩展你的代码以适应他们的需要，你有很多选择：</p>
<h3 id=" 回调函数 ">回调函数</h3>
<p>回调函数可以用来根据配置实现可扩展性。你可以使用回调函数允许 API 用户覆盖你的代码中的某些部分。当你感觉某些任务可能不会像你提供的默认的代码那样处理，将这部分代码重构为一个可配置的回调函数，来允许 API 使用者易于重载：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">var</span> default_options = {
  <span class="comment">// ...</span>
  position: <span class="function"><span class="keyword">function</span><span class="params">($elem, $parent)</span> {</span>
    $elem.css($parent.position());
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">Widget</span><span class="params">(options)</span> {</span>
  <span class="keyword">this</span>.options = jQuery.extend({}, default_options, options || {});
  <span class="keyword">this</span>.create();
};

Widget.prototype.create = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$container = $(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>).appendTo(document.body);
  <span class="keyword">this</span>.$thingie = $(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>).appendTo(<span class="keyword">this</span>.$container);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

Widget.protoype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.options.position(<span class="keyword">this</span>.$thingie, <span class="keyword">this</span>.$container);
  <span class="keyword">this</span>.$thingie.show();
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> widget = <span class="keyword">new</span> Widget({
  position: <span class="function"><span class="keyword">function</span><span class="params">($elem, $parent)</span> {</span>
    <span class="keyword">var</span> position = $parent.position();
    <span class="comment">// position $elem at the lower right corner of $parent</span>
    position.left += $parent.width();
    position.top += $parent.height();
    $elem.css(position);
  }
});
widget.show();
</pre></td></tr></table></figure>



<p>回调函数也是一种常见的允许 API 使用者定制你的代码创建的元素的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// default create callback doesn't do anything</span>
default_options.create = <span class="function"><span class="keyword">function</span><span class="params">($thingie)</span>{</span>};

Widget.prototype.create = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.$container = $(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>).appendTo(document.body);
  <span class="keyword">this</span>.$thingie = $(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>).appendTo(<span class="keyword">this</span>.$container);
  <span class="comment">// execute create callback to allow decoration</span>
  <span class="keyword">this</span>.options.create(<span class="keyword">this</span>.$thingie);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> widget = <span class="keyword">new</span> Widget({
  create: <span class="function"><span class="keyword">function</span><span class="params">($elem)</span> {</span>
    $elem.addClass(<span class="string">'my-style-stuff'</span>);
  }
});
widget.show();
</pre></td></tr></table></figure>



<p>每当你的 API 接受回调函数时，确保文档化其签名，并提供示例帮助 API 使用者定制代码。确保回调函数所执行的上下文（<code>this</code>的指向），以及接收的参数都保持一致性。</p>
<h3 id=" 事件 ">事件</h3>
<p>当需要处理 DOM 时，事件自然而然出现。在大型的应用中我们以各种机制（例如 PubSub）使用事件使模块间通讯变得可能。当处理 UI 控件时，事件尤为有用并且很自然。像 jQuery 这样的库提供了简单的接口，允许你很容易实现这方面的需求。</p>
<p>当有事情发生时事件介入最佳——这正是事件的得名由来。根据外部环境显示或是隐藏一个控件，当控件显示时更新它——这些都是很常见的交互。借助于 jQuery 的事件接口，这些都很容易实现，甚至允许使用事件委托：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>Widget.prototype.show = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> event = jQuery.Event(<span class="string">"widget:show"</span>);
  <span class="keyword">this</span>.$container.trigger(event);
  <span class="keyword">if</span> (event.isDefaultPrevented()) {
    <span class="comment">// event handler prevents us from showing</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">this</span>.options.position(<span class="keyword">this</span>.$thingie, <span class="keyword">this</span>.$container);
  <span class="keyword">this</span>.$thingie.show();
  <span class="keyword">return</span> <span class="keyword">this</span>;
};


<span class="comment">// listen for all widget:show events</span>
$(document.body).on(<span class="string">'widget:show'</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span> {</span>
  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) {
    <span class="comment">// prevent widget from showing</span>
    event.preventDefault();
  }

  <span class="comment">// update widget's data</span>
  $(<span class="keyword">this</span>).data(<span class="string">"last-show"</span>, <span class="keyword">new</span> <span class="built_in">Date</span>());
});

<span class="keyword">var</span> widget = <span class="keyword">new</span> Widget();
widget.show();
</pre></td></tr></table></figure>



<p>你可以任意选择事件名。避免在处理专有的事件使用<a href="https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference" target="_blank">原生事件</a>，并且考虑将你的事件放入命名空间下。jQuery UI 的事件名都是由部件名和事件名组合而成的，例如<code>dialogshow</code>。我觉得这样难以阅读所以常将其改为<code>dialog:show</code>的默认写法，主要是因为这样一看便知是一个自定义事件，而不是某些特定浏览器的私有实现。</p>
<h2 id=" 钩子机制 ">钩子机制</h2>
<p>传统的 getter/setter 方法特别能受益于钩子机制。钩子机制通常在数量和如何注册方面有别于回调函数。回调函数通常应用于特定任务的实例级，而钩子则往往应用于全局级别自定义值或是调度自定义行为。为了演示钩子如何使用，让我们看看<a href="http://api.jquery.com/jQuery.cssHooks/" target="_blank">jQuery’s cssHooks</a>中的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="comment">// define a custom css hook</span>
jQuery.cssHooks.custombox = {
  get: <span class="function"><span class="keyword">function</span><span class="params">(elem, computed, extra)</span> {</span>
    <span class="keyword">return</span> $.css(elem, <span class="string">'borderRadius'</span>) == <span class="string">"50%"</span>
      ? <span class="string">"circle"</span>
      : <span class="string">"box"</span>;
  },
  set: <span class="function"><span class="keyword">function</span><span class="params">(elem, value)</span> {</span>
    elem.style.borderRadius = value == <span class="string">"circle"</span>
      ? <span class="string">"50%"</span>
      : <span class="string">"0"</span>;
  }
};

<span class="comment">// have .css() use that hook</span>
$(<span class="string">"#some-selector"</span>).css(<span class="string">"custombox"</span>, <span class="string">"circle"</span>);
</pre></td></tr></table></figure>



<p>通过注册<code>custombox</code>这个钩子，jQuery 的<code>.css()</code>方法拥有了可以处理一个之前无法处理的 CSS 属性的能力。在我的<a href="http://blog.rodneyrehm.de/archives/11-jQuery-Hooks.html" target="_blank">jQuery hooks</a>一文中，我谈到了 jQuery 提供的一些其他的钩子，以及在实践中如何应用。你可以像处理回调一样提供钩子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>DateInterval.nameHooks = {
  <span class="string">"yesterday"</span> : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();
    d.setTime(d.getTime() - <span class="number">86400000</span>);
    d.setHours(<span class="number">0</span>);
    d.setMinutes(<span class="number">0</span>);
    d.setSeconds(<span class="number">0</span>);
    <span class="keyword">return</span> d;
  }
};

DateInterval.prototype.start = <span class="function"><span class="keyword">function</span><span class="params">(date)</span> {</span>
  <span class="keyword">if</span> (date === <span class="literal">undefined</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.startDate.getTime());
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> date === <span class="string">"string"</span> &amp;&amp; DateInterval.nameHooks[date]) {
    date = DateInterval.nameHooks[date]();
  }

  <span class="keyword">if</span> (!(date <span class="keyword">instanceof</span> <span class="built_in">Date</span>)) {
    date = <span class="keyword">new</span> <span class="built_in">Date</span>(date);
  }

  <span class="keyword">this</span>.startDate.setTime(date.getTime());
  <span class="keyword">return</span> <span class="keyword">this</span>;
};


<span class="keyword">var</span> di = <span class="keyword">new</span> DateInterval();
di.start(<span class="string">"yesterday"</span>);
</pre></td></tr></table></figure>



<p>从某种程度上讲，钩子是一系列被设计为以你自己的代码来处理自定义值的回调函数。有了钩子，你可以将差不多任何东西保持在可控范围内，同时提供 API 使用者定制的选择。</p>
<h2 id=" 生成访问器 ">生成访问器</h2>
<p><img src="/img/jsapis/duplication.jpg" alt="duplication"></p>
<p>任何一个 API 多半都会有完成类似工作的多种访问方法（getters，setters，executors）。回到<code>DateInterval</code>的例子，我们应该会提供<code>start()</code>和<code>end()</code>方法以允许对时间间隔的操作。可以像这样简单解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>DateInterval.prototype.start = <span class="function"><span class="keyword">function</span><span class="params">(date)</span> {</span>
  <span class="keyword">if</span> (date === <span class="literal">undefined</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.startDate.getTime());
  }

  <span class="keyword">this</span>.startDate.setTime(date.getTime());
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

DateInterval.prototype.end = <span class="function"><span class="keyword">function</span><span class="params">(date)</span> {</span>
  <span class="keyword">if</span> (date === <span class="literal">undefined</span>) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>.endDate.getTime());
  }

  <span class="keyword">this</span>.endDate.setTime(date.getTime());
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>



<p>如你所见，这里有很多重复性代码。采用生成器模式可以提供一种 DRY(Don’t Repeat Yourself) 解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> accessors = [<span class="string">"start"</span>, <span class="string">"end"</span>];
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = accessors.length; i &lt; length; i++) {
  <span class="keyword">var</span> key = accessors[i];
  DateInterval.prototype[key] = generateAccessor(key);
}

<span class="function"><span class="keyword">function</span> <span class="title">generateAccessor</span><span class="params">(key)</span> {</span>
  <span class="keyword">var</span> value = key + <span class="string">"Date"</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(date)</span> {</span>
    <span class="keyword">if</span> (date === <span class="literal">undefined</span>) {
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">this</span>[value].getTime());
    }

    <span class="keyword">this</span>[value].setTime(date.getTime());
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
}
</pre></td></tr></table></figure>



<p>这种方式允许你生成多种类似的访问器方法，而不是单独定义每个方法。如果你的访问器方法需要更多的数据以配置，而不是一个简单的字符串，考虑像下面的方式书写代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> accessors = {<span class="string">"start"</span> : {color: <span class="string">"green"</span>}, <span class="string">"end"</span> : {color: <span class="string">"red"</span>}};
<span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> accessors) {
  DateInterval.prototype[key] = generateAccessor(key, accessors[key]);
}

<span class="function"><span class="keyword">function</span> <span class="title">generateAccessor</span><span class="params">(key, accessor)</span> {</span>
  <span class="keyword">var</span> value = key + <span class="string">"Date"</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(date)</span> {</span>
    <span class="comment">// setting something up </span>
    <span class="comment">// using `key` and `accessor.color`</span>
  };
}
</pre></td></tr></table></figure>



<p>在<em>处理参数</em>那一节我们讨论到一种方法模式，允许你的 getters/setters 方法接受多种实用的类型，例如映射和数组。这种方法模式本身就是非常通用的，并且可以很容易转为一个生成器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">wrapFlexibleAccessor</span><span class="params">(get, set)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(name, value)</span> {</span>
    <span class="keyword">var</span> map;

    <span class="keyword">if</span> (jQuery.isPlainObject(name)) {
      <span class="comment">// setting a map</span>
      map = name;
    } <span class="keyword">else</span> <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) {
      <span class="comment">// setting a value (on possibly multiple names), convert to map</span>
      keys = name.split(<span class="string">" "</span>);
      map = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) {
        map[keys[i]] = value;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> get.call(<span class="keyword">this</span>, name);
    }

    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> map) {
      set.call(<span class="keyword">this</span>, name, map[key]);
    }

    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
}

DateInterval.prototype.values = wrapFlexibleAccessor(
  <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span> 
    <span class="keyword">return</span> name !== <span class="literal">undefined</span> 
      ? <span class="keyword">this</span>.values[name]
      : <span class="keyword">this</span>.values;
  },
  <span class="function"><span class="keyword">function</span><span class="params">(name, value)</span> {</span>
    <span class="keyword">this</span>.values[name] = value;
  }
);
</pre></td></tr></table></figure>



<p>本文并不打算深入讲述编写符合 DRY 原则的代码。如果你对这个主题还比较生疏，<a href="https://twitter.com/rmurphey" target="_blank">Rebecca Murphey</a>的<a href="http://rmurphey.com/blog/2010/07/12/patterns-for-dry-er-javascript/" target="_blank">《Patterns for DRY-er JavaScript》</a>一文和<a href="https://twitter.com/mathias" target="_blank">Mathias Bynens</a>的幻灯片<a href="http://slideshare.net/mathiasbynens/how-dry-impacts-javascript-performance-faster-javascript-execution-for-the-lazy-developer" target="_blank">《how DRY impacts JavaScript performance》</a>都是很好的起步教程。</p>
<h2 id=" 引用之怖 ">引用之怖</h2>
<p>不同于其他语言，JavaScript 中不存在<em>按引用传递</em>和<em>按值传递</em>的概念。按值传递是比较安全的做法，可以确保你的 API 中输入和输出的数据在外部被修改时，不会更改内部的状态。按引用传值往往是为了保持较低的内存开销，按引用传递的值可能会在你的 API 之外的任何地方被修改并影响其内部状态。</p>
<p>在 JavaScript 中无法判断参数应该按应用传递还是按值传递。基本类型（字符串、数字、布尔值）都被处理为<em>按值传递</em>，但是对象（任何对象，包括 Array、Date）都以类似于按<em>引用</em>的方式进行处理。如果你初次接触这个话题，下面这个例子可以启发你：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">// by value</span>
<span class="function"><span class="keyword">function</span> <span class="title">addOne</span><span class="params">(num)</span> {</span>
  num = num + <span class="number">1</span>; <span class="comment">// yes, num++; does the same</span>
  <span class="keyword">return</span> num;
}

<span class="keyword">var</span> x = <span class="number">0</span>;
<span class="keyword">var</span> y = addOne(x);
<span class="comment">// x === 0 &lt;--</span>
<span class="comment">// y === 1</span>

<span class="comment">// by reference</span>
<span class="function"><span class="keyword">function</span> <span class="title">addOne</span><span class="params">(obj)</span> {</span>
  obj.num = obj.num + <span class="number">1</span>;
  <span class="keyword">return</span> obj;
}

<span class="keyword">var</span> ox = {num : <span class="number">0</span>};
<span class="keyword">var</span> oy = addOne(ox);
<span class="comment">// ox.num === 1 &lt;--</span>
<span class="comment">// oy.num === 1</span>
</pre></td></tr></table></figure>



<p>如果你不注意，对对象的<em>按引用</em>处理有可能会反过来给你带来麻烦。回到<code>DateInterval</code>的例子，看看下面这个棘手的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">31</span>)
<span class="keyword">var</span> interval = <span class="keyword">new</span> DateInterval(startDate, endDate);
endDate.setMonth(<span class="number">0</span>); <span class="comment">// set to january</span>
<span class="keyword">var</span> days = interval.days(); <span class="comment">// got 31 but expected 365 - ouch!</span>
</pre></td></tr></table></figure>



<p>除非 DateInterval 的构造器为它接受的值<em>创建拷贝</em>（<code>clone</code>是创建拷贝的术语），否则任何在原始对象上的改变都会直接反映到 DateInterval 的内部。这<em>往往</em>不是我们所想要或是所期望的。</p>
<p>注意，你的 API 中的返回值同样存在这样的隐患。如果你只是返回一个内部对象，你的 API 外部的任何变化都会反映到内部数据中。毫无疑问这并非你想要的。<a href="http://api.jquery.com/jQuery.extend/" target="_blank">jQuery.extend()</a>、<a href="http://underscorejs.org/#extend" target="_blank">_.extend()</a> 以及 Protoype 的<a href="http://api.prototypejs.org/language/Object/extend/" target="_blank">Object.extend</a> 让你可以轻松摆脱引用之怖。</p>
<p>如果这里总结得还不够，你还可以读一读 O’Reilly 的<a href="http://docstore.mik.ua/orelly/webprog/jscript/index.htm" target="_blank">《JavaScript – The Definitive Guide》</a>一书中<a href="http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm" target="_blank">《By Value Versus by Reference》</a>，讲得非常棒。</p>
<h2 id=" 连续性问题 ">连续性问题</h2>
<p>在连贯接口中，链上的每个方法都会被执行，不论对象主体处于什么状态。考虑在一个不包含任何 DOM 元素的 jQuery 实例上调用一些方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery(<span class="string">'.wont-find-anything'</span>)
  <span class="comment">// executed although there is nothing to execute against</span>
  .somePlugin().someOtherPlugin();
</pre></td></tr></table></figure>



<p>在非链式的代码中，我们可以避免这些方法被执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> $elem = jQuery(<span class="string">'.wont-find-anything'</span>);
<span class="keyword">if</span> ($elem.length) {
  $elem.somePlugin().someOtherPlugin();
}
</pre></td></tr></table></figure>



<p>只要我们将方法链接起来，我们就无法避免这样的事情发生——我们无法逃离这条链。对象可能遇到这种情形，即方法实际上不做任何事仅仅<code>return this;</code>，只要 API 开发者能意识到这一点就没事。依据你的方法的内部实现，在前面加一个简单的<code>is-empty</code>检测可以会有帮助：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>jQuery.fn.somePlugin = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.length) {
    <span class="comment">// "abort" since we've got nothing to work with</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">// do some computational heavy setup tasks</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">10000</span>; i &gt; <span class="number">0</span>; i--) {
    <span class="comment">// I'm just wasting your precious CPU!</span>
    <span class="comment">// If you call me often enough, I'll turn</span>
    <span class="comment">// your laptop into a rock-melting jet engine</span>
  }

  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">// do the actual job</span>
  });
};
</pre></td></tr></table></figure>



<h2 id=" 处理错误 ">处理错误</h2>
<p><img src="/img/jsapis/fail-faster.jpg" alt="Fail faster"></p>
<p>我之前说我们无法从链中逃出来，其实是骗你的——对于这条规则有一个<code>Exception</code>（请不要介意这个双关语☺）</p>
<p>通过抛出错误（异常）我们就可以强制退出。抛出错误往往被认为是当前执行流的蓄意中止，往往可能是因为你陷入无法恢复的状态。但是当心——并不是所有的错误都会帮助开发者调试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// jQuery accepts this</span>
$(document.body).on(<span class="string">'click'</span>, {});

<span class="comment">// on click the console screams</span>
<span class="comment">//   TypeError: ((p.event.special[l.origType] || {}).handle || l.handler).apply is not a function </span>
<span class="comment">//   in jQuery.min.js on Line 3</span>
</pre></td></tr></table></figure>



<p>遇到这样的错误信息是调试时最痛苦的事。不要浪费他人的时间。如果 API 使用者用得不对，请告知他：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(callback) !== <span class="string">'[object Function]'</span>) { <span class="comment">// see note</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"callback is not a function!"</span>);
}
</pre></td></tr></table></figure>



<p>注意：<code>typeof callback === &quot;function&quot;</code>不应被使用，因为老式浏览器会认为对象是<code>function</code>，事实上它们不是。Chrome（直到版本 12）中的<code>RegExp</code>就是如此。方便起见，使用<a href="http://api.jquery.com/jQuery.isfunction/" target="_blank">jQuery.isFunction()</a>或是<a href="http://underscorejs.org/#isFunction" target="_blank">_.isFunction()</a>。</p>
<p>对于语言（内置弱类型域 (weak-typing domain)）不在意严格的输入验证这一点，我接触过的大部分库采取了无视的态度。老实说，我也只在预感开发者会出错的时候在代码中进行校验。没有人真的做了，但是我们都应该去做。程序员是一个懒惰的群体——我们不会只是为了写代码或者某些我们并不真正相信的理由而写代码。Perl 6 的开发者们已经意识到这是个问题，并且决定引入叫做<em>参数约束</em>的东西。在 JavaScript 中，它可能会是这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>function validateAllTheThings(a, b {where typeof b === "numeric" and b &lt; 10}) {
  // Interpreter should throw an Error if b is
  // not a number or greater than 9
}
</pre></td></tr></table></figure>



<p>尽管语法上看上去很丑陋，主要思想是要使输入验证称为这门语言的一个顶级公民。JavaScript 与这样的东西差之千里。这样也不错——不管怎样，我也不愿看到函数签名中塞满这样一些约束。承认这个（弱类型语言中的）问题是这个故事中有意思的部分。</p>
<p>JavaScript 既不弱也不低等，我们只是需要更努力一点工作以使我们的代码变得真正健壮。使代码具有健壮性并不意味着不论接受什么数据，只要挥挥魔杖就能得到结果。健壮性是指不接受垃圾<em>并且告之开发者</em>。</p>
<p>换个角度考虑输入验证：在你的 API 后面加几行代码，就可以确保开发者不必花费几个小时来跟踪诡异的错误，结果发现原来他们意外地给你的代码中传入了字符串而不是数字。这种时候你应该告诉用户<em>输入有误</em>，他们实际上会喜欢你这么做的。</p>
<h2 id=" 向异步出发 ">向异步出发</h2>
<p>目前我们只讨论了同步的 API。异步方法通常接受一个回调函数，从而在某个任务完成时通知外部环境。虽然在连贯接口中这样并不是非常合适：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Api.protoype.async = <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
  console.log(<span class="string">"async()"</span>);
  <span class="comment">// do something asynchronous</span>
  window.setTimeout(callback, <span class="number">500</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
Api.protoype.method = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  console.log(<span class="string">"method()"</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};
</pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">// running things</span>
api.async(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  console.log(<span class="string">'callback()'</span>);
}).method();

<span class="comment">// prints: async(), method(), callback()</span>
</pre></td></tr></table></figure>



<p>这个例子演示了什么情况下异步方法<code>async()</code>虽然开始执行但立即返回，却会导致<code>method()</code>在<code>async()</code>真正完成前就被调用了。某些时候我们需要这么做，但通常我们都期望<code>method()</code>在<code>async()</code>完成任务<em>之后</em>才会被执行。</p>
<h3 id=" 延迟机制（允诺 (Promise)）">延迟机制（允诺 (Promise)）</h3>
<p>某种程度上，我们可以借助<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank">允诺 (Promise)</a>来解决同步和异步 API 调用混搭导致的混乱。jQuery 称之为<a href="http://api.jquery.com/category/deferred-object/" target="_blank">延迟机制</a>。用延迟替代常见的<code>this</code>，从而迫使你从方法链中强行退出。这起初看上去有点怪，但是可以有效地避免在调用一个异步方法之后继续同步执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Api.prototype.async = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> deferred = $.Deferred();
  console.log(<span class="string">"async()"</span>);

  window.setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">// do something asynchronous</span>
    deferred.resolve(<span class="string">"some-data"</span>);
  }, <span class="number">500</span>);

  <span class="keyword">return</span> deferred.promise();
};
</pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>api.async().done(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> {</span>
  console.log(<span class="string">"callback()"</span>);
  api.method();
});

<span class="comment">// prints: async(), callback(), method()</span>
</pre></td></tr></table></figure>



<p>延迟对象使你可以使用<code>.done()</code>、<code>.fail()</code>、<code>.always()</code>注册一些处理器，当异步任务完成或失败时，或者不关心状态如何，再调用它们。关于延迟机制更详细的介绍参见<a href="http://sitr.us/2012/07/31/promise-pipelines-in-javascript.html" target="_blank">《Promise Pipelines In JavaScript》</a>。</p>
<h2 id=" 调试连贯接口 ">调试连贯接口</h2>
<p>虽然<em>连贯接口</em>更便于开发中使用，但就可调试性而言，会带来一些限制。</p>
<p>对于任何代码，<em>测试驱动开发</em>(TDD) 是减少调试需求的一种简单方法。在使用 TDD 完成 URI.js 中，就调试代码而言，我没有遇到什么严重的痛苦。然而，TDD 仅仅<em>减少</em>了调试的需要——并不会完全替代之。</p>
<p>有网民声称，可以在单独的行中书写链中的每个部件，从而在堆栈跟踪时获得正确的行号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>foobar.bar()
  .baz()
  .bam()
  .someError();
</pre></td></tr></table></figure>



<p>这种技巧确实有它的好处（尽管不包括更好的调试技术）。像上面例子中这样书写代码更易于阅读。基于行的差异（在例如 SVN、GIT 这样的版本控制系统中有用到）也会带来细微的优势。关于智能调试，（目前）只有 Chrome 会将<code>someError()</code>展示在第四行，而其他浏览器则仍将其看作第一行。</p>
<p>添加一个简单的方法 log 你的对象会很有用——尽管这样会被视为“手工调试”，并且会被那些习惯了“真实”的调试器的人看不惯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>DateInterval.prototype.explain = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// log the current state to the console</span>
  console.dir(<span class="keyword">this</span>);
};

<span class="keyword">var</span> days = (<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">0</span>, <span class="number">1</span>))
  .until(<span class="number">2012</span>, <span class="number">11</span>, <span class="number">31</span>) <span class="comment">// returns DateInterval instance</span>
  .explain() <span class="comment">// write some infos to the console</span>
  .days(); <span class="comment">// 365</span>
</pre></td></tr></table></figure>



<h3 id=" 函数名 ">函数名</h3>
<p>在本文中你随处可见很多<code>Foo.prototype.something = function(){}</code>这种风格的演示代码。这种风格是为了保持例子比较简洁。当编写 API 时你可能会考虑如下方式之一来使你的控制台正确地识别出函数名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>Foo.prototype.something = <span class="function"><span class="keyword">function</span> <span class="title">something</span><span class="params">()</span> {</span>
  <span class="comment">// yadda yadda</span>
};
</pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Foo.prototype.something = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// yadda yadda</span>
};
Foo.prototype.something.displayName = <span class="string">"Foo.something"</span>;
</pre></td></tr></table></figure>



<p>第二种方式中<code>displayName</code>是由 WebKit 引入的，之后被 Firebug/Firefox 所采纳。<code>displayName</code>需要多写点代码，但是允许任意的名字，包括命名空间或是关联对象。两者中的任何一种都对于处理匿名函数很有帮助。</p>
<p>关于这个话题的更多细节参见<a href="https://twitter.com/kangax" target="_blank">kangax</a>的<a href="http://kangax.github.com/nfe/" target="_blank">《Named function expressions demystified》</a>。</p>
<h2 id=" 文档化 API">文档化 API</h2>
<p>软件开发中最困难的任务之一就是文档化。几乎所有人都讨厌做这件事，然而所有人都感叹他们需要使用的工具的文档纰漏或是缺失。目前有各种各样据说能提供帮助和自动文档化你的代码的工具：</p>
<ul>
<li><a href="http://yui.github.com/yuidoc/" target="_blank">YUIDoc</a> (requires Node.js, npm)</li>
<li><a href="https://github.com/p120ph37/node-jsdoc-toolkit" target="_blank">JsDoc Toolkit</a> (requires Node.js, npm)</li>
<li><a href="https://github.com/cbou/markdox" target="_blank">Markdox</a> (requires Node.js, npm)</li>
<li><a href="https://github.com/visionmedia/dox" target="_blank">Dox</a> (requires Node.js, npm)</li>
<li><a href="http://jashkenas.github.com/docco/" target="_blank">Docco</a> (requires Node.js, Python, CoffeeScript)</li>
<li><a href="https://github.com/senchalabs/jsduck" target="_blank">JSDuck</a> (reqires Ruby, gem)</li>
<li><a href="https://github.com/jsdoc3/jsdoc" target="_blank">JSDoc 3</a> (requires Java)</li>
</ul>
<p>所有这些工具都会在某些方面不尽如人意。JavaScript 是一种非常动态的语言，尤其在表达方式上特别多样化。这使得很多东西对这些工具而言比较困难。下面重点列出了一些我决定采用普通的 HTML、markdown 或是<a href="http://en.wikipedia.org/wiki/DocBook" target="_blank">DocBoock</a>（如果这个项目足够大）制定文档的原因。譬如，jQuery 同样遇到了这些问题，但根本不在代码中文档化 API。</p>
<ol>
<li>你需要文档化的并不仅仅是函数签名，但是大多数工具都只关注于此；</li>
<li>示例代码可以为解释工作原理带来极大的帮助，但普通的 API 文档通常无法以合理的折衷来阐释；</li>
<li>API 文档解释<em>幕后</em>的东西（流、事件等等）时会遭遇滑铁卢；</li>
<li>文档化多签名方法往往实在很痛苦；</li>
<li>文档化使用 option 对象的方法通常并不简单；</li>
<li>生成方法不容易被文档化，默认回调也是。</li>
</ol>
<p>如果你不能（或不想）调整你的代码以适应列出的文档化工具之一，类似<a href="http://gregfranko.com/Document-Bootstrap/" target="_blank">Document-Bootstrap</a>这样的项目可能会节省你一些时间来建立你自己酝酿的文档。</p>
<p>确保你的文档化不只是一些生成的 API 文档。你的用户会感激你提供的示例。告诉他们你的软件如何工作的，以及当执行某件事时都会牵涉到哪些事件。如果有助于他们理解你的软件到底做了些什么，为他们画一张图。最重要的是，保持你的文档与你的代码同步！</p>
<h3 id=" 自解释的代码 ">自解释的代码</h3>
<p>提供优秀的文档并不会使开发者不用阅读你的代码——你的代码本身就是文档的一部分。当文档不够用时（每个文档都是有限的），开发者会回到阅读源代码获取答案。事实上，你也是他们中的一员。很可能你会一边又一遍地阅读你自己的代码，几周、几个月甚至几年之间。</p>
<p>你应该编写可以自解释的代码。大部分时候这并不是个问题，只有当你为（函数、变量等等）命名殚精竭虑、保持核心概念时才会涉及到。如果你发现你在写代码注释以文档化你的代码如何工作，你很可能在浪费时间——你的时间，还有读者的时间。在你的代码中的注释应该解释<em>为何</em>你以这种特殊的方式解决问题，而不是解释你<em>如何</em>解决问题。<em>如何</em>解决问题应该在你的代码中很明显，所以不要自我重复。注意，使用注释以标示你的代码中的区块，或是解释普通概念，这些都是完全可接受的。</p>
<h3 id=" 结语 ">结语</h3>
<ul>
<li>API 是你（提供者）和用户（消费者）之间的契约。不要在版本之间发生变化。</li>
<li>你应该投入跟解决<em>我的软件内部如何工作？</em>的问题同样多的时间，来解决<em>用户会如何使用我的软件？</em>这个问题。</li>
<li>只要一些简单的技巧你就可以很显著地减少开发者的辛苦（就代码行数而言）</li>
<li>尽可能早地处理非法输入——抛出错误</li>
<li>好的 API 都是弹性的，更好的 API 让你避免犯错</li>
</ul>
<p>继续阅读<a href="http://vimeo.com/35689836" target="_blank">《Reusable Code for good or for awesome》</a>（<a href="http://www.slideshare.net/jaffathecake/reusable-code-for-good-or-for-awesome" target="_blank">幻灯片</a>），这是<a href="https://twitter.com/jaffathecake" target="_blank">Jake Archibald</a>关于设计 API 的一番讨论。早在 2007 年 Joshua Bloch 在 Google 技术讲座上做了题为<a href="http://www.youtube.com/watch?v=heh4OeB9A-c" target="_blank">《How to Design A Good API and Why it Matters》</a>演讲。虽然他的讨论并不集中于 JavaScript，他解释的基本原理仍然适用。</p>
<p>既然你已经掌握了关于 API 设计的最新进展，读一读<a href="https://twitter.com/addyosmani" target="_blank">Addy Osmani</a>写的<a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank">《Essential JS Design Patterns》</a>来了解更多关于如何组织你的内部代码吧。</p>
<p><em>感谢<a href="https://twitter.com/bassistance" target="_blank">@bassistance</a>、<a href="https://twitter.com/addyosmani" target="_blank">@addyosmani</a>和<a href="https://twitter.com/hellokahlil" target="_blank">@hellokahlil</a>抽出时间校验本文。</em></p>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/翻译/">翻译</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/JavaScript API/">JavaScript API</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<!-- Duoshuo Comment BEGIN -->
<div class="ds-thread"></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"dickeyblog"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- Duoshuo Comment END -->
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:dickeylth.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/每周播报/">每周播报</a><small>30</small></li>
  
    <li><a href="/categories/笔记/">笔记</a><small>7</small></li>
  
    <li><a href="/categories/翻译/">翻译</a><small>7</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/F2E Weekly/" style="font-size: 20.00px;">F2E Weekly</a><a href="/tags/Gulp/" style="font-size: 10.00px;">Gulp</a><a href="/tags/JavaScript/" style="font-size: 13.33px;">JavaScript</a><a href="/tags/JavaScript API/" style="font-size: 10.00px;">JavaScript API</a><a href="/tags/JavaScript设计模式/" style="font-size: 16.67px;">JavaScript设计模式</a><a href="/tags/MVC/" style="font-size: 10.00px;">MVC</a><a href="/tags/Node.js/" style="font-size: 10.00px;">Node.js</a><a href="/tags/Promise/" style="font-size: 13.33px;">Promise</a>
  </div>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/03/22/F2EWeekly/">F2E Weekly-2015-03-22</a>
      </li>
    
      <li>
        <a href="/2015/03/15/F2EWeekly/">F2E Weekly-2015-03-15</a>
      </li>
    
      <li>
        <a href="/2014/12/07/F2EWeekly/">F2E Weekly-2014-12-07</a>
      </li>
    
      <li>
        <a href="/2014/11/09/F2EWeekly/">F2E Weekly-2014-11-09</a>
      </li>
    
      <li>
        <a href="/2014/09/21/F2EWeekly/">F2E Weekly-2014-09-21</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 Dickey Leo
  
</div>
<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- Baidu Statics -->
<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F9e7e898e944bfabd3e130209a93d1339' type='text/javascript'%3E%3C/script%3E"));
</script>
</body>
</html>